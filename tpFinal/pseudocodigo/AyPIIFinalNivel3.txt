NIVEL 3 

funcion obtenerEmail(E cad:cadena)
{Que Hace: devuelve una direccion de email valida
PRE: cad = C 
POST: obtenerEmail = M ; M es un email valido
EXCEP: }
Var
	ok:logico
	email:cadena
	i:entero
Inicio
	ok <- V

	repetir 
		ingresar(cad)
		desde i <- 1 hasta long(cad) hacer
			ok <- ok y (cad[i] = @) //esto podria ser mejor 
		finDesde
	hasta ok

Fin

procedimiento actualizarSC(E/S serv:tipoLista, E viejoDni, dni:tipoClaveClientes)
{Que Hace: actualiza el dni de un cliente en el listado de servicio
PRE: serv = S ; viejoDni = T ; dni = R
POST: serv = S1; S1 podria tener en los servicios con dniCliente = R en lugar de dniCliente = T
EXCEP: }
Var
	datosServicio:tipoInfoServicios
	codigoServicio:tipoClaveServicios
	sigo:logico
Inicio
	si (no(esVacia(serv))) entonces
		sigo <- V
		recuPrim(serv, codigoServicio) {ADT LO}

		mientras sigo hacer
			Inicio
				recuClave(serv, codigoServicio, datosServicio) {ADT LO}
				
				si (datosServicio.dniCliente = viejoDni) entonces
					datosServicio.dniCliente <- dni 				{SC}
				finSi

				suprimir(serv, codigoServicio) {ADT LO}
				insertar(serv, codigoServicio, datosServicio) {ADT LO}

				recuSig(serv, codigoServicio, codigoServicio) {ADT LO}
			Excepciones 
				claveEsUltima => sigo <- F
			Fin
		finMientras
	finSi
Excepciones
	listaLlena => lanzar errorEnModificarCliente
Fin

procedimiento limpiarVehiculo(E/S vehiculos:tipoListaVahiculos ; E patente:tipoClaveVehiculos)
{Qué Hace: Vacía las estructuras de datos pertenecientes a un vehículo
PRE: vehiculos = A ; patente = P
POST: vehiculos = A1 ; A1 en A con las estructuras pertenecientes a P vacías
EXCEP:
}
Var
	datosVehiculo:tipoInfoVehiculos
Inicio
	recuClave(vehiculos, patente, datosVehiculo)	{ADT LO}

	vaciar(datosVehiculo.manten)					{ADT LO}

	modificar(vehiculos, patente,datosVehiculo)		{ADT LO}
Fin

procedimiento limpiarCliente (E/S client:tipoArbolCLientes ; E dni:tipoClaveClientes)
{Qué Hace: vacía todas las estructuras de datos pertenecientes a un cliente
PRE: client = C; dni = D ; D pertenece a C
POST: client = C1 ; C1 en C con las estructuras correspondientes al cliente D vacías
EXCEP:	
}
Var
	sigo:logico
	datosCliente:tipoInfoClientes
	patente:tipoClaveVehiculo
	datosVehiculo:tipoInfoVehiculo
Incio
	//recuperar el cliente a limpiar
	buscar(client, dni, datosCliente)	{ADT ABB}

	sigo <- V

	//recorrer la lista de vehiculos y por cada uno limpiar la lista de mantenimientos
	recuPrim(datosCliente.vehiculos, patente)	{ADT LO}
	mientras sigo hacer
		Inicio
			recuClave(datosCliente.vehiculos, patente, datosVehiculo)	{ADT LO}
			
			//vacío la lista de mantenimientos
			vaciar(datosVehiculo.manten)								{ADT LO}
			//actualizo en la lista
			modificar(datosCliente.vehiculo, patente, datosVehiculo)	{ADT LO}
			
			recuSig(datosCliente.vehiculos, patente, patente)			{ADT LO}
		Excepciones
			claveEsUltima => sigo <- F
		Fin
	finMientras

	//vacío la lista de vehículos
	vaciar (datosCliente.vehiculos)

	modificar(client, dni, datosCliente)
Excepciones
	
Fin

procedimiento bajaSC(E/S serv:tipoListaServicios ; E dni:tipoClaveClientes)
{Qué Hace: da de baja los servicios a nombre de un cliente en particular
PRE: serv = S ; dni = D
POST:	serv = S1 ; S1 en S menos los servicios con dniCliente = D, que fueron eliminados
EXCEP: }
Var
	siguiente:tipoClaveServicios
	codigoServicio:tipoClaveServicios
	datosServicio:tipoInfoServicios
	sigo:logico
Inicio
	sigo <- V
	recuPrim(serv, codigoServicios)						{ADT LO}

	Inicio
		recuSig(serv, codigoServicio, siguiente)		{ADT LO}
	Excepciones
		claveEsUltima => siguiente <- codigoServicio
	Fin

	mientras sigo hacer
		Inicio
			recuClave(serv, codigoServicio, datosServicio)	{ADT LO}

			si datosServicio.dniCliente = dni entonces
				suprimir(serv, codigoServicio)				{ADT LO}
				codigoServicio <- siguiente

				Inicio
					recuSig(serv, siguiente, siguiente)		{ADT LO}
				Excepciones
					claveEsUltima => nada
				Fin
			siNo
				recuSig(serv, codigoServicio, codigoServicio)	{ADT LO}
			finSi
		Excepciones
			claveNoExiste, claveEsUltima => sigo <- F
		Fin
	finMientras
Excepciones

Fin

funcion generarCodigoModelo(E model:tipoListaModelos)
{Qué Hace: genera el codigo de modelo correspondiente a un nuevo modelo
PRE: model = M
POST:	generarCodigoModelo = CM ; CM es un codigo de modelo valido
EXCEP: }
Var
	codigo:tipoClaveModelos
Inicio
	si (esVacia(model)) entonces
		generarCodigoModelo <- 1
	siNo
		recuUlt(model, codigo)
		generarCodigoModelo <- codigo + 1
	finSi	
Fin

funcion obtenerModelo(E model:tipoListaModelos)
{Qué Hace: obtiene un codigo válido de modelo
PRE: model = M
POST:
EXCEP: noHayModelos,cancelarIngreso}
Var
	ok:logico
	modelo:tipoClaveModelos
	dm:tipoInfoModelos
Inicio
	
	si(esVacia(model)) entonces
		lanzar noHayModelos				{SC}
	siNo
		ok <- F
		repetir
			mostrar("Ingrese codigo de modelos (0 para cancelar ingreso)")
			ingresar(modelo)	{SC}

			si modelo = 0 entonces
				lanzar cancelarIngreso	{SC}
			siNo
				Inicio
					recuClave(model, modelo, dm)	{ADT LO}
					ok <- V 						{SC}
				Excepciones	
					claveNoExiste => mostrar("Codigo de modelo invalido")	{SC}
				Fin
			finSi
		hasta ok
	finSi

	obtenerModelo <- modelo
Fin

procedimiento menuModifModelo()
{Qué Hace: muestra un menu con las opciones para modificar los datos de un modelo
PRE:
POST:
EXCEP:}
Inicio
	mostrar("	MODIFICAR MODELO")
	mostrar("1 - Moficar Nombre")
	mostrar("2 - Agregar, modificar o quitar etapas del calendario de su calendario de mantenimientos")
	mostrar("3 - Volver al menú anterior")
Fin

procedimiento ABMCalendario(E/S calendario:tipoListaCalendario)
{Qué Hace: Permite agregar, quitar o modificar etapas del calendario de mantenimientos de un modelo
PRE: calendario = C
POST: calendario = C1 ; C1 en C según lo haya querido el usuario
EXCEP: }
Var
	opc:entero
Incio
	repetir
		mostrarMenuCalendario()				{nivel 4}
		ingresar(opc)						{SC}

		segun opc hacer
			1:agregarEtapa(calendario)		{nivel 4}
			2:modificarEtapa(calendario)	{nivel 4}
			3:quitarEtapa(calendario)		{nivel 4}
		finSegun
	hasta opc = 4							{SC}
Excepciones

Fin

procedimiento bajaSMant(E/S serv:tipoListaServicios, E calendario:tipoListaCalendario)
{Qué Hace: actualiza los servicios con respecto a las etapas de mantenimiento existentes
PRE: serv = S ; client = C ; calendario = F 
POST: 
EXCEP: - }
Var
	siguiente:tipoClaveServicios
	datosEtapa:tipoInfoCalendario
	codigoServicio:tipoClaveServicios
	datosServicio:tipoInfoServicios
	sigo:logico
Inicio
	sigo <- V 										{SC}

	recuPrim(serv, codigoServicios)					{ADT LO}

	Inicio
		recuSig(serv, codigoServicio, siguiente)		{ADT LO}
	Excepciones
		claveEsUltima => siguiente <- codigoServicio 	{SC}         
	Fin

	mientras sigo hacer
		Inicio
			recuClave(serv, codigoServicio, datosServicio)				{ADT LO}
			
			Incio
				recuClave(calendario, datosServicio.etapa, datosEtapa)	{ADT LO}
				recuSig(serv, codigoServicio, codigoServicio)			{ADT LO}
			Excepciones
				claveNoExiste => 
					Inicio
						suprimir(serv, codigoServicio)					{ADT LO}
						codigoServicio <- siguiente						{SC}

						Inicio
							recuSig(serv, siguiente, siguiente)			{ADT LO}
						Excepciones
							claveEsUltima => nada						{SC}
						Fin
					Fin
			Fin
		Excepciones
			claveNoExiste, claveEsUltima => sigo <- F 					{SC}
		Fin
	finMientras

Excepciones

Fin

procedimiento actualizaVS(E/S client:tipoArbolClientes, E serv:tipoListaServicios)
{Qué Hace: actualiza los vehiculos con respecto a los servicios
PRE: client = C ; serv = S
POST: client = C1 ; C1 en C menos los servicios correspondientes a codigos inexistentes en S
EXCEP: - }
Var
	sigo:logico
	codigoServicio:tipoClaveServicios
	dni:tipoClaveClientes
	datosCliente:tipoInfoClientes
	colaClientes:tipoColaClientes
	patente:tipoClaveVehiculo
	datosVehiculo:tipoInfoVehiculo

Inicio
	crear(colaClientes)				{ADT Cola}			
	inOrder(client, colaClientes)	{ADT ABB}

	mientras(no(esVacia(colaClientes))) hacer
		frente(colaClientes, dni)	{ADT Cola}
		desencolar(colaClientes)	{ADT Cola}

		buscar(client, dni, datosCliente)			{ADT ABB}

		sigo <- V
		recuPrim(datosCliente.vehiculos, patente)	{ADT LO}
		mientras sigo hacer 
			Inico
				recuClave(datosCliente.vehiculo, patente, datosVehiculo)	{ADT LO}

				bajaMantS(datosVehiculo.manten, serv)						{nivel 4}

				recuSig(datosCliente.vehiculo, patente, patente)			{ADT LO}
			Excepciones
				claveEsUltima => sigo <- F 									{SC}
			FIn
		finMientras
	finMientras
Fin

Excepciones

procedimiento limpiarModelo(E/S model:tipoListaModelos, E codigoModelo:tipoClaveModelos)
{Que Hace: vacia las estructuras de un modelo en particular
PRE: model = M ; codigoModelo = K
POST: model = M1 ; M1 en M, salvo el modelo de codigo K que tiene ese modelo con las estructuras vacias
EXCEP: - }
Var
	datosModelo:tipoInfoModelos
Inicio
	recuClave(model, codigoModelo, datosModelo)		{ADT LO}

	vaciar(datosModelo.calendario)					{ADT LO}

	modificar(model, codigoModelo, datosModelo)		{ADT LO}
Excepciones
Fin

funcion obtenerPatente():cadena
{Que Hace:
PRE: - 
POST:	obtenerCadena = P ;P es una patente valida
EXCEP:	-	}
Var
	letras:cadena
	numeros:entero
Inicio

	repetir
		mostrar("Ingrese letras")			{SC}
		ingresar(letras)					{SC}
	hasta ((letras <= "zzz") y (letras <= "ZZZ")) o ((letras >= "aaa") y (letras >= "AAA"))

	repetir
		mostrar("Ingrese numeros")			{SC}
		ingresar(numeros)					{SC}
	hasta ((numeros <= 999) y (numeros>= 0))

	obtenerPatente <- letras + enteroACadena(numeros)	{SC}
Excepciones

Fin

funcion obtenerVehiculo(E vehiculos:tipoListaVehiculos)
{Que Hace: devuelve un vehiculo valido de una lista de vehiculos
PRE: vehiculos = L
POST: obtenerVehiculo = A ; A pertence a  L
EXCEP: noHayVehiculos}
Var
	ok:logico
	patente:tipoClaveVehiculos
	datosVehiculo:tipoInfo
Inicio
	ok <- F
	repetir
		patente <- obtenerPatente() {nivel 3}
		Inicio
			recuClave(vehiculos, patente, datosVehiculo) {ADT LO}	
			ok <- V
		Excepciones
			listaVacia => lanzar noHayVehiculos								{SC}
			claveNoExiste => mostrar("Vehiculo no pertece al cliente")		{SC}
		Fin
	hasta ok

	obtenerVehiculo <- patente 												{SC}
Excepciones
Fin

procedimiento bajaSV(E/S serv:tipoListaServicios; E patente:tipoClaveVehiculos)
{Que Hace: actualiza los servicios con respecto a los vehiculos existentes
PRE: serv = S ; patente = P
POST: serv = S1 ; S1 en S menos los servicios realizados a vehiculos de patente P
EXCEP: - }
Var
	siguiente:tipoClaveServicios
	sigo:logico
	codigoServicio:tipoClaveServicios
	datosServicio:tipoInfoServicios
Inicio
	
	sigo <- V
	recuPrim(serv, codigoServicios)

	Inicio
		recuSig(serv, codigoServicio, siguiente)		{ADT LO}
	Excepciones
		claveEsUltima => siguiente <- codigoServicio 	{SC}
	Fin

	mientras sigo hacer
		Inicio
			recuClave(serv, codigoServicio, datosServicio)	{ADT LO}

			si datosServicio.dominio = patente entonces
				suprimir(serv, codigoServicio)				{ADT LO}
				codigoServicio <- siguiente					{SC}

				Inicio
					recuSig(serv, siguiente, siguiente)		{ADT LO}
				Excepciones
					claveEsUltima => nada					{SC}
				Fin
			siNo
				recuSig(serv, codigoServicio, codigoServicio)	{ADT LO}
			finSi
		Excepciones
			claveNoExiste, claveEsUltima => sigo <- F 			{SC}
		Fin
	finMientras

Excepciones
Fin 

funcion generarCodigoServicio(E serv:tipoListaServicios)
{Que Hace: devuelve un nuevo codigo de servicio valido
PRE: serv = S
POST: generarCodigoServicio = K ; K es un codigo valido en S
EXCEP: - }
Var
	ok:logico
	codigo:tipoClaveServicios
Inicio
	si esVacia(serv) entonces
		codigo <- 1
	siNo
		recuUlt(serv, codigo)
		codigo <- codigo + 1
	finSi

	generarCodigoServicio <- codigo
Excepciones

Fin


funcion obtenerEtapaValida(E model:tipoListaModelos ; E vehiculos:tipoListaVehiculos ; E dominio:tipoClaveVehiculos)
{Que Hace: devuelve una etapa del calendario de mantenimientos valida correspondiente a un modelo
PRE: model = M ; vehiculos = A ; dominio = D ; D pertenece a A
POST: obtenerEtapaValida = E ; E es una etapa valida al vehiculo de dominio D, perteneciente a A con modelo en M
EXCEP: }
Var
	datosModelo:tipoInfoModelos
	ok:logico
	etapa:tipoClaveCalendario
	datosEtapa:tipoInfoCalendario
	datosVehiculo:tipoInfoVehiculos
Inicio
	ok <- F

	repetir
		mostrar("Ingrese etapa de mantenimiento")
		ingresar(etapa)
		recuClave(vehiculos, patente, datosVehiculo)
		recuClave(model, datosVehiculo.modelo, datosModelo)

		Inicio
			recuClave(datosModelo.calendario, etapa, datosEtapa)
			ok <- V
		Excepciones
			claveNoExiste => ("Etapa invalida")
		Fin
	hasta ok

	obtenerEtapaValida <- etapa

Fin

funcion obtenerKmReal(E model:tipoListaModelo  client, datosServicio.dominio)

Procedimiento menuModifClient()
que hace: muestra las opciones para modificar un cliente
pre:-
pos:-
exp:-

Inicio
	mostrar("¿Que desea modificar?")
	mostrar("1- DNI")
	mostrar("2- Nombre")
	mostrar("3- Numero de Telefono")
	mostrar("4- E-Mail")
FinProcedimiento

Procedimiento mostrarCabeceraMantenPorCliente(E: nomCli:cadena)
que hace: muestra la cabecera de los mantenimientos de un cliente
pre: nomCli=N y N no es vacio
pos: -
exp: -

Inicio
	mostrar("Mantenimientos realizados por el cliente", nomCli)
	mostrar("Codigo servicio 	Dominio		etapa 	Km Real 	Fecha de Mantenimiento 		Precio Final")
	mostrar("___________________________________________________________________________________________")
FinProcedimiento

Procedimiento mostrarDatosServicio(E datosServicio:tipoInfoServicios, E codigoServicio:tipoClaveServicios)
que hace: muestra los datos de servicio de mantenimiento realizado por un cliente
pre: datosServicio=D y D tiene que tener datos validos; codigoServicio=C y tiene un codigo valido
pos: -
exp: -

Inicio
	mostrar(codigoServicio, "   " , datosServicio.Dominio, "  ", datosServicio.etapa, "   ", datosServicio.KmReal, "  ", datosServicio.fecha,"   ", datosServicio.precioFinal)
FinProcedimiento

Procedimiento mostrarEncabezadoMantModelo (E nomMod:cadena, E dniCliente:entero)
que hace: muestra el encabezado de los mantenimientos por modelo
pre: nomMod=N y N tiene un nombre de modelo valido
pos: -
exp: -

Inicio
	mostrar("Mantenimientos realidos por el modelo", nomMod, "Al cliente:",dniCliente)
	mostrar("Codigo servicio 	Dominio		etapa 	Km Real 	Fecha de Mantenimiento 		Precio Final")
FinProcedimiento

Procedimiento mostrarEncabezadoClientSinMant()
que hace: muestra el encabezado de los clientes sin mantenimientos
pre:-
pos:-
exp:-

Inicio
	mostrar("Datos de los clientes que no han realizado ningun mantenimiento en sus vehiculos")
	mostrar("DNI 	Nombre 	  Telefono 	 E-Mail ")
FinProcedimiento

Procedimiento mostrarClientes(E datosCliente:tipoInfoClientes, E dni:entero)
que hace: muestra los datos de los clientes que no han realizado mantenimientos
pre: datosCliente=C y C tiene datos validos
pos: 
exp:

Inicio
	mostrar(dni,"  ", datosCliente.nombre,"  ", datosCliente.Telefono, "  ", datosCliente.email)
FinProcedimiento